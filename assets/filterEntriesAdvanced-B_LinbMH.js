const g=({advancedFilterGroups:f,entries:a,groupIndex:i,valueIndex:o})=>{if(!a||a.length===0)return[];const h=Array.isArray(f)?f:[];if(h.length===0||i<0)return a;const A=t=>{if(!t||!t.fieldName)return null;const e=t.fieldName,s=Array.isArray(t.values)?t.values.filter(n=>n!=null&&String(n).length):[];if(s.length===0)return null;const u=(t.operator||"AND").toUpperCase()==="OR"?"OR":"AND",c=(t.matchType||"Is").toLowerCase()==="is not";return{fieldName:e,values:s,operator:u,negative:c}};let r=h.map(A).filter(Boolean);if(r.length===0)return a;if(Number.isFinite(i)&&i>=0&&(r=r.slice(0,Math.min(i+1,r.length))),r.length>0&&Number.isFinite(o)&&o>=0){const t=r.length-1,e=r[t];Array.isArray(e.values)&&e.values.length>0&&(e.values=e.values.slice(0,Math.min(o+1,e.values.length)))}return a.filter(t=>r.every(({fieldName:e,values:s,operator:u,negative:c})=>{const n=t[e],m=l=>Array.isArray(n)?n.includes(l):n===l,p=s.some(l=>m(l)),N=s.every(l=>m(l)),y=u==="OR"?p:N;return c?!y:y}))};export{g as f};
